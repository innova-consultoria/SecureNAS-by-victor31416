# ============================================
# AUDITORÍA FINAL MAESTRA - PowerShell Script
# Integración Completa de Fases 1 a 5
# Versión: 3.0.1 (MEJORADA)
# Autor: victor 3,1416 (Ene'26)
# ============================================

# ============================================
# AUDITORÍA COMPLETA DISEÑADA POR victor 3,1416
# Equipo: [Se completará automáticamente]
# Fecha: [Se completará automáticamente]
# Hora: [Se completará automáticamente]
# ============================================

#region PARÁMETROS CONFIGURABLES
param (
    [string]$OutputPath = "$env:USERPROFILE\Auditoria-Final",
    [switch]$QuickAudit = $false,
    [switch]$FullAudit = $true,
    [switch]$SecurityCheck = $false,
    [switch]$ExportHTML = $true,
    [switch]$AutoClean = $false,
    [int]$DownloadCleanupDays = 30,
    [switch]$EnableStorageSense = $false
)
#endregion

#region CONFIGURACIÓN INICIAL
$scriptStartTime = Get-Date
$ComputerName = $env:COMPUTERNAME
[switch]$ExportHTML = $true
$Timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$global:AuditData = @{}
$global:CurrentPhase = 0
$global:TotalPhases = 5
$global:Fase3ExportHTML = $ExportHTML

# Configurar ruta de salida
if (-not [string]::IsNullOrEmpty($OutputPath)) {
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
    }
} else {
    $scriptDir = if ($PSScriptRoot) { $PSScriptRoot } else { Get-Location }
    $OutputPath = Join-Path $scriptDir $ComputerName
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
    }
}

# Crear subcarpetas para cada fase
$phaseFolders = @{}
1..5 | ForEach-Object {
    $phaseFolder = Join-Path $OutputPath "Fase$_"
    if (-not (Test-Path $phaseFolder)) {
        New-Item -ItemType Directory -Path $phaseFolder -Force | Out-Null
    }
    $phaseFolders[$_] = $phaseFolder
}
$PhaseFoldersForExport = @{  # ← NUEVA VARIABLE: con nombres específicos que necesita Fase 3
    Fase1 = $phaseFolders[1]
    Fase2 = $phaseFolders[2]
    Fase3 = $phaseFolders[3]
}

# Archivos de salida unificados
$UnifiedCSV = Join-Path $OutputPath "$ComputerName`_AuditoriaCompleta_$Timestamp.csv"
$UnifiedJSON = Join-Path $OutputPath "$ComputerName`_AuditoriaCompleta_$Timestamp.json"
$UnifiedHTML = Join-Path $OutputPath "$ComputerName`_AuditoriaCompleta_$Timestamp.html"
$UnifiedMD = Join-Path $OutputPath "$ComputerName`_AuditoriaCompleta_$Timestamp.md"
$LogFile = Join-Path $OutputPath "$ComputerName`_AuditoriaCompleta_$Timestamp.log"

# Inicializar log
"===================================================" | Out-File -FilePath $LogFile -Encoding UTF8
"AUDITORÍA COMPLETA DISEÑADA POR victor 3,1416" | Out-File -FilePath $LogFile -Append -Encoding UTF8
"Equipo: $ComputerName" | Out-File -FilePath $LogFile -Append -Encoding UTF8
"Fecha: $(Get-Date -Format 'dd/MM/yyyy')" | Out-File -FilePath $LogFile -Append -Encoding UTF8
"Hora: $(Get-Date -Format 'HH:mm:ss')" | Out-File -FilePath $LogFile -Append -Encoding UTF8
"===================================================" | Out-File -FilePath $LogFile -Append -Encoding UTF8
" " | Out-File -FilePath $LogFile -Append -Encoding UTF8
# ✅ AÑADE: Inicialización específica para Fase 3 en el log
"CONFIGURACIÓN FASE 3:" | Out-File -FilePath $LogFile -Append -Encoding UTF8
"• Exportación HTML habilitada: $ExportHTML" | Out-File -FilePath $LogFile -Append -Encoding UTF8
"• Carpeta Fase 3: $($phaseFolders[3])" | Out-File -FilePath $LogFile -Append -Encoding UTF8
" " | Out-File -FilePath $LogFile -Append -Encoding UTF8
#endregion

#region FUNCIONES DE SOPORTE
function Write-Log {
    param(
        [string]$Message,
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "$timestamp [$Level] $Message"
    
    # Colores para consola
    $color = switch ($Level) {
        "INFO"    { "Gray" }
        "WARNING" { "Yellow" }
        "ERROR"   { "Red" }
        "SUCCESS" { "Green" }
        default   { "White" }
    }
    
    Write-Host "[LOG] $Message" -ForegroundColor $color
    $logMessage | Out-File -FilePath $LogFile -Append -Encoding UTF8
}

function Show-Progress {
    param(
        [int]$PhaseNumber,
        [string]$PhaseName,
        [int]$Percent
    )
    
    $global:CurrentPhase = $PhaseNumber
    $phaseProgress = [math]::Round(($PhaseNumber - 1) / $global:TotalPhases * 100 + ($Percent / $global:TotalPhases))
    
    Write-Host "`n" + ("="*60) -ForegroundColor Cyan
    Write-Host "FASE $PhaseNumber/$global:TotalPhases: $PhaseName" -ForegroundColor Cyan
    Write-Host "Progreso total: $phaseProgress%" -ForegroundColor Yellow
    Write-Host ("[" + ("#" * [math]::Round($Percent/5)) + (" " * (20 - [math]::Round($Percent/5))) + "]") -ForegroundColor Green -NoNewline
    Write-Host " $Percent% completado de esta fase" -ForegroundColor White
    Write-Host ("="*60) -ForegroundColor Cyan
}

function Test-Modules {
    Write-Log "Verificando módulos PowerShell requeridos..." -Level "INFO"
    
    $requiredModules = @(
        "CimCmdlets",
        "Dism",
        "NetAdapter",
        "NetTCPIP",
        "Storage"
    )
    
    foreach ($module in $requiredModules) {
        if (Get-Module -ListAvailable -Name $module) {
            Write-Log "✓ Módulo disponible: $module" -Level "SUCCESS"
        } else {
            Write-Log "⚠ Módulo no disponible: $module (algunas funciones pueden fallar)" -Level "WARNING"
        }
    }
    
    # Verificar PowerShell versión
    $psVersion = $PSVersionTable.PSVersion.Major
    if ($psVersion -ge 5) {
        Write-Log "✓ PowerShell versión $psVersion detectada" -Level "SUCCESS"
    } else {
        Write-Log "⚠ PowerShell versión $psVersion detectada (se recomienda v5.1 o superior)" -Level "WARNING"
    }
}

function Show-AuditHeader {
    param(
        [string]$Title,
        [string]$Subtitle = ""
    )
    
    $header = @"
===================================================
        $Title
===================================================
Auditoría completa diseñada por victor 3,1416
Equipo: $ComputerName
Fecha: $(Get-Date -Format 'dd/MM/yyyy')
Hora: $(Get-Date -Format 'HH:mm:ss')
$(if ($Subtitle) { "Nota: $Subtitle`n" })
"@
    
    Write-Host $header -ForegroundColor Cyan
    $header | Out-File -FilePath $LogFile -Append -Encoding UTF8
}
#endregion

#region CLASES DE DATOS UNIFICADAS
class SystemInfo {
    [string]$ComputerName
    [string]$Domain
    [string]$Workgroup
    [string]$OSName
    [string]$OSVersion
    [string]$OSBuild
    [string]$InstallDate
    [string]$TimeZone
    [string]$LastBoot
    [string]$UptimeHours
    [string]$Locale
    [string]$KeyboardLayout
    [string]$Fabricante
    [string]$Modelo
    [string]$NumeroSerie
    [double]$RAM_GB
    [string]$Procesador
    [string]$Nucleos
    [string]$DireccionIP
    [string]$DireccionMAC
    # Propiedades adicionales para compatibilidad
    [string]$FechaAuditoria
    [string]$Hostname
    [string]$UsuarioActual
    [string]$Dominio
    [string]$SistemaOperativo
    [string]$VersionOS
    [string]$Arquitectura
    [string]$UltimoArranque
    [string]$TiempoActividad
}

class DiskInfo {
    [string]$Disco
    [string]$Tipo
    [string]$Model
    [string]$Serial
    [double]$SizeGB
    [double]$FreeGB
    [double]$PercentFree
    [string]$SistemaArchivos
    [string]$HealthStatus
    [string]$Temperature
}

class UserProfileInfo {
    [string]$UserName
    [string]$ProfilePath
    [datetime]$LastUseTime
    [double]$SizeGB
    [int]$DaysInactive
    [string]$ActivityStatus
    [double]$Size_MB
    [string]$Estado
    # Propiedades adicionales para compatibilidad
    [string]$Usuario
    [string]$RutaPerfil
    [double]$Tamano_MB
}

class ApplicationInfo {
    [string]$Name
    [string]$Version
    [string]$Publisher
    [datetime]$InstallDate
    [string]$InstallSource
}

class PrinterInfo {
    [string]$Name
    [string]$DriverName
    [string]$PortName
    [string]$Type
    [bool]$Shared
    [string]$Status
    [string]$ComputerName
    [string]$IPAddress
    [string]$MarcaModelo
    [string]$RutaRed
}

class UpdateInfo {
    [string]$HotFixID
    [string]$Description
    [datetime]$InstalledOn
    [string]$InstalledBy
}

class ProcessInfo {
    [string]$Name
    [string]$PID
    [string]$CPUPercent
    [string]$MemoryMB
    [string]$Status
    [string]$Company
    [string]$IsCritical
}

class ServiceInfo {
    [string]$Name
    [string]$DisplayName
    [string]$Status
    [string]$StartType
    [string]$IsCritical
    [string]$RequiredState
}

class SecurityStatus {
    [string]$FirewallStatus
    [string]$DefenderStatus
    [string]$LastAntivirusScan
    [string]$RealTimeProtection
    [string]$WindowsUpdates
    [string]$UACStatus
    [string]$AutoLoginDisabled
    [string]$PasswordPolicy
}

class SystemHealth {
    [string]$OverallScore
    [string]$DiskHealth
    [string]$MemoryHealth
    [string]$CPUHealth
    [string]$NetworkHealth
    [string]$SecurityHealth
    [string]$SpaceManagementHealth
    [string]$Recommendations
}

class DownloadFolderAudit {
    [string]$User
    [string]$DownloadPath
    [double]$Size_GB
    [int]$FileCount
    [datetime]$OldestFile
    [datetime]$NewestFile
    [int]$FilesOlderThan30Days
    [int]$FilesOlderThan90Days
    [double]$PotentialFreeSpace_GB
    [string]$Recommendation
}
#endregion

#region FUNCIONES DE FASE 1 (CONFIGURACIÓN BÁSICA)
function Invoke-Fase1 {
    Show-Progress -PhaseNumber 1 -PhaseName "CONFIGURACIÓN BÁSICA" -Percent 10
    Show-AuditHeader -Title "INICIO DE AUDITORÍA - FASE 1" -Subtitle "Configuración básica del sistema"
    
    Write-Log "Iniciando Fase 1: Configuración básica" -Level "INFO"
    $fase1Start = Get-Date
    
    try {
        # Crear estructura de carpetas si no existe
        if (-not (Test-Path $OutputPath)) {
            New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
            Write-Log "Directorio creado: $OutputPath" -Level "SUCCESS"
        }
        
        # Verificar módulos requeridos
        Test-Modules
        
        # Crear archivo de log inicial
        Write-Log "=== INICIO AUDITORÍA COMPLETA ===" -Level "INFO"
        Write-Log "Auditoría completa diseñada por victor 3,1416" -Level "INFO"
        Write-Log "Equipo: $ComputerName" -Level "INFO"
        Write-Log "Fecha: $(Get-Date -Format 'dd/MM/yyyy HH:mm:ss')" -Level "INFO"
        Write-Log "Parámetros: OutputPath=$OutputPath, QuickAudit=$QuickAudit, FullAudit=$FullAudit" -Level "INFO"
        
        Show-Progress -PhaseNumber 1 -PhaseName "CONFIGURACIÓN BÁSICA" -Percent 100
        $fase1Duration = [math]::Round(((Get-Date) - $fase1Start).TotalSeconds, 2)
        Write-Log "Fase 1 completada en $fase1Duration segundos" -Level "SUCCESS"
        
        return $true
    }
    catch {
        Write-Log "Error en Fase 1: $_" -Level "ERROR"
        return $false
    }
}

function Get-SystemAuditBasic {
    [CmdletBinding()]
    param()
    
    Show-Progress -PhaseNumber 1 -PhaseName "AUDITORÍA BÁSICA DEL SISTEMA" -Percent 20
    Show-AuditHeader -Title "AUDITORÍA BÁSICA DEL SISTEMA" -Subtitle "Recolección de información fundamental"
    
    Write-Log "Recopilando información básica del sistema..." -Level "INFO"
    
    # ✅ CORRECCIÓN: Declarar variable de inicio
    $fase1Start = Get-Date
    
    $systemData = @{}
    
    try {
        # 1. INFORMACIÓN BÁSICA DEL SISTEMA
        $systemInfo = [SystemInfo]::new()
        
        $systemInfo.FechaAuditoria = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $systemInfo.Hostname = $ComputerName
        $systemInfo.UsuarioActual = $env:USERNAME
        $systemInfo.Dominio = $env:USERDOMAIN
        
        # Obtener información WMI/CIM
        $osInfo = Get-CimInstance Win32_OperatingSystem -ErrorAction SilentlyContinue
        $computerInfo = Get-CimInstance Win32_ComputerSystem -ErrorAction SilentlyContinue
        $biosInfo = Get-CimInstance Win32_BIOS -ErrorAction SilentlyContinue
        $processorInfo = Get-CimInstance Win32_Processor -ErrorAction SilentlyContinue | Select-Object -First 1
        
        # ✅ CORRECCIÓN: Validar que existan datos antes de usarlos
        if ($osInfo) {
            $systemInfo.SistemaOperativo = $osInfo.Caption
            $systemInfo.VersionOS = $osInfo.Version
            $systemInfo.Arquitectura = $osInfo.OSArchitecture
            $systemInfo.UltimoArranque = $osInfo.LastBootUpTime.ToString("yyyy-MM-dd HH:mm:ss")
            $systemInfo.TiempoActividad = [math]::Round(((Get-Date) - $osInfo.LastBootUpTime).TotalHours, 2)
        } else {
            Write-Log "⚠ No se pudo obtener información del SO" -Level "WARNING"
            $systemInfo.SistemaOperativo = "No detectado"
            $systemInfo.VersionOS = "N/A"
            $systemInfo.Arquitectura = "N/A"
            $systemInfo.UltimoArranque = "N/A"
            $systemInfo.TiempoActividad = "N/A"
        }
        
        if ($computerInfo) {
            $systemInfo.Fabricante = $computerInfo.Manufacturer
            $systemInfo.Modelo = $computerInfo.Model
            $systemInfo.RAM_GB = [math]::Round($computerInfo.TotalPhysicalMemory / 1GB, 2)
        } else {
            Write-Log "⚠ No se pudo obtener información del equipo" -Level "WARNING"
            $systemInfo.Fabricante = "No detectado"
            $systemInfo.Modelo = "N/A"
            $systemInfo.RAM_GB = 0
        }
        
        if ($biosInfo) {
            $systemInfo.NumeroSerie = $biosInfo.SerialNumber
        } else {
            $systemInfo.NumeroSerie = "N/A"
        }
        
        if ($processorInfo) {
            $systemInfo.Procesador = $processorInfo.Name
            $systemInfo.Nucleos = "$($processorInfo.NumberOfCores)/$($processorInfo.NumberOfLogicalProcessors)"
        } else {
            $systemInfo.Procesador = "No detectado"
            $systemInfo.Nucleos = "N/A"
        }
        
        # Información de red
        try {
            $ipConfig = Get-NetIPConfiguration -ErrorAction SilentlyContinue | Where-Object { $_.IPv4DefaultGateway -ne $null } | Select-Object -First 1
            if ($ipConfig -and $ipConfig.IPv4Address) {
                $systemInfo.DireccionIP = $ipConfig.IPv4Address.IPAddress
            } else {
                $systemInfo.DireccionIP = "No disponible"
            }
        } catch {
            $systemInfo.DireccionIP = "Error al obtener"
        }
        
        try {
            $macInfo = Get-NetAdapter -ErrorAction SilentlyContinue | Where-Object { $_.Status -eq "Up" } | Select-Object -First 1
            if ($macInfo) {
                $systemInfo.DireccionMAC = $macInfo.MacAddress
            } else {
                $systemInfo.DireccionMAC = "No disponible"
            }
        } catch {
            $systemInfo.DireccionMAC = "Error al obtener"
        }
        
        # Copiar a propiedades compatibles
        $systemInfo.ComputerName = $systemInfo.Hostname
        $systemInfo.Domain = $systemInfo.Dominio
        $systemInfo.OSName = $systemInfo.SistemaOperativo
        $systemInfo.OSVersion = $systemInfo.VersionOS
        $systemInfo.LastBoot = $systemInfo.UltimoArranque
        $systemInfo.UptimeHours = $systemInfo.TiempoActividad
        
        # Guardar datos en la estructura global
        $systemData.SystemInfo = $systemInfo
        
        Show-Progress -PhaseNumber 1 -PhaseName "AUDITORÍA BÁSICA DEL SISTEMA" -Percent 40
        
        # 2. INFORMACIÓN DE DISCOS
        Write-Log "Analizando discos..." -Level "INFO"
        $diskData = @()
        
        try {
            $logicalDisks = Get-CimInstance Win32_LogicalDisk -ErrorAction SilentlyContinue
            
            if ($logicalDisks) {
                foreach ($disk in $logicalDisks) {
                    $diskInfo = [DiskInfo]::new()
                    $diskInfo.Disco = $disk.DeviceID
                    $diskInfo.Tipo = switch ($disk.DriveType) {
                        2 { "Removible" }
                        3 { "Local" }
                        4 { "Red" }
                        5 { "CD-ROM" }
                        default { "Desconocido" }
                    }
                    $diskInfo.SizeGB = if ($disk.Size -gt 0) { [math]::Round($disk.Size / 1GB, 2) } else { 0 }
                    $diskInfo.FreeGB = if ($disk.FreeSpace -gt 0) { [math]::Round($disk.FreeSpace / 1GB, 2) } else { 0 }
                    $diskInfo.PercentFree = if ($disk.Size -gt 0) { [math]::Round(($disk.FreeSpace / $disk.Size) * 100, 2) } else { 0 }
                    $diskInfo.SistemaArchivos = if ($disk.FileSystem) { $disk.FileSystem } else { "N/A" }
                    $diskInfo.Model = if ($disk.VolumeName) { $disk.VolumeName } else { "Sin nombre" }
                    $diskInfo.Serial = "N/A"
                    $diskInfo.HealthStatus = "N/A"
                    $diskInfo.Temperature = "N/A"
                    
                    $diskData += $diskInfo
                }
            } else {
                Write-Log "⚠ No se detectaron discos lógicos" -Level "WARNING"
            }
        } catch {
            Write-Log "Error al obtener información de discos: $_" -Level "ERROR"
        }
        
        $systemData.DiskInfo = $diskData
        
        Show-Progress -PhaseNumber 1 -PhaseName "AUDITORÍA BÁSICA DEL SISTEMA" -Percent 60

# 3. PERFILES DE USUARIO
        Write-Log "Analizando perfiles de usuario..." -Level "INFO"
        $userProfiles = @()
        
        try {
            $profiles = Get-CimInstance Win32_UserProfile -ErrorAction SilentlyContinue | Where-Object { -not $_.Special }
            
            if ($profiles) {
                foreach ($profile in $profiles) {
                    try {
                        $profilePath = $profile.LocalPath
                        $userName = Split-Path $profilePath -Leaf
                        
                        # ✅ CORRECCIÓN: Validar que la ruta existe antes de procesar
                        if (-not (Test-Path $profilePath)) {
                            Write-Log "⚠ Perfil $userName no accesible en $profilePath" -Level "WARNING"
                            continue
                        }
                        
                        $profileInfo = [UserProfileInfo]::new()
                        $profileInfo.UserName = $userName
                        $profileInfo.ProfilePath = $profilePath
                        
                        # Calcular tamaño con manejo de errores
                        try {
                            $sizeBytes = (Get-ChildItem -Path $profilePath -Recurse -Force -ErrorAction SilentlyContinue | 
                                         Measure-Object -Property Length -Sum -ErrorAction SilentlyContinue).Sum
                            
                            if ($sizeBytes -gt 0) {
                                $profileInfo.Size_MB = [math]::Round($sizeBytes / 1MB, 2)
                                $profileInfo.SizeGB = [math]::Round($sizeBytes / 1GB, 2)
                            } else {
                                $profileInfo.Size_MB = 0
                                $profileInfo.SizeGB = 0
                            }
                        } catch {
                            Write-Log "⚠ No se pudo calcular tamaño de perfil $userName" -Level "WARNING"
                            $profileInfo.Size_MB = 0
                            $profileInfo.SizeGB = 0
                        }
                        
                        # Fecha de último uso
                        if ($profile.LastUseTime) {
                            $profileInfo.LastUseTime = $profile.LastUseTime
                        } else {
                            $profileInfo.LastUseTime = [datetime]::MinValue
                        }
                        
                        # Calcular días inactivos
                        if ($profileInfo.LastUseTime -ne [datetime]::MinValue) { 
                            $profileInfo.DaysInactive = [math]::Round(((Get-Date) - $profileInfo.LastUseTime).TotalDays, 0)
                        } else { 
                            $profileInfo.DaysInactive = 999
                        }
                        
                        # Estado
                        if ($profile.Loaded) { 
                            $profileInfo.Estado = "Cargado"
                            $profileInfo.ActivityStatus = "Activo"
                        } else { 
                            $profileInfo.Estado = "Inactivo"
                            if ($profileInfo.DaysInactive -lt 30) {
                                $profileInfo.ActivityStatus = "Reciente"
                            } else {
                                $profileInfo.ActivityStatus = "Inactivo"
                            }
                        }
                        
                        # Propiedades compatibles
                        $profileInfo.Usuario = $profileInfo.UserName
                        $profileInfo.RutaPerfil = $profileInfo.ProfilePath
                        $profileInfo.Tamano_MB = $profileInfo.Size_MB
                        
                        $userProfiles += $profileInfo
                        
                    } catch {
                        Write-Log "Error procesando perfil ${userName}: $_" -Level "WARNING"
                    }
                }
            } else {
                Write-Log "⚠ No se detectaron perfiles de usuario" -Level "WARNING"
            }
        } catch {
            Write-Log "Error al obtener perfiles de usuario: $_" -Level "ERROR"
        }
        
        $systemData.UserProfiles = $userProfiles
        
        Show-Progress -PhaseNumber 1 -PhaseName "AUDITORÍA BÁSICA DEL SISTEMA" -Percent 80
        
        # 4. APLICACIONES INSTALADAS
        Write-Log "Recopilando aplicaciones instaladas..." -Level "INFO"
        $applications = @()
        
        try {
            $uninstallPaths = @(
                "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*",
                "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
            )
            
            foreach ($path in $uninstallPaths) {
                try {
                    $items = Get-ItemProperty -Path $path -ErrorAction SilentlyContinue | Where-Object { $_.DisplayName }
                    
                    foreach ($item in $items) {
                        $app = [ApplicationInfo]::new()
                        $app.Name = $item.DisplayName
                        $app.Version = if ($item.DisplayVersion) { $item.DisplayVersion } else { "N/A" }
                        $app.Publisher = if ($item.Publisher) { $item.Publisher } else { "N/A" }
                        
                        # ✅ CORRECCIÓN: Parseo seguro de fecha de instalación
                        if ($item.InstallDate -and $item.InstallDate -match '^\d{8}$') {
                            try { 
                                $app.InstallDate = [datetime]::ParseExact($item.InstallDate, 'yyyyMMdd', $null) 
                            } catch { 
                                $app.InstallDate = [datetime]::MinValue 
                            }
                        } else { 
                            $app.InstallDate = [datetime]::MinValue 
                        }
                        
                        $app.InstallSource = if ($item.InstallSource) { $item.InstallSource } else { "Registry" }
                        $applications += $app
                    }
                } catch {
                    Write-Log "⚠ Error accediendo a ruta $path" -Level "WARNING"
                }
            }
        } catch {
            Write-Log "Error al obtener aplicaciones instaladas: $_" -Level "ERROR"
        }
        
        $systemData.Applications = $applications
        
        # 5. IMPRESORAS CONFIGURADAS
        Write-Log "Recopilando impresoras..." -Level "INFO"
        $printers = @()
        
        try {
            # ✅ CORRECCIÓN: Usar Get-Printer en lugar de WMI
            $printerList = Get-Printer -ErrorAction SilentlyContinue
            
            if ($printerList) {
                foreach ($printer in $printerList) {
                    $printerInfo = [PrinterInfo]::new()
                    $printerInfo.Name = $printer.Name
                    $printerInfo.DriverName = if ($printer.DriverName) { $printer.DriverName } else { "N/A" }
                    $printerInfo.PortName = if ($printer.PortName) { $printer.PortName } else { "N/A" }
                    $printerInfo.Type = if ($printer.PortName -like "*\*") { "Compartida" } else { "Local" }
                    $printerInfo.Shared = $printer.Shared
                    $printerInfo.Status = $printer.PrinterStatus.ToString()
                    $printerInfo.ComputerName = $ComputerName
                    
                    # Extraer IP del puerto si es posible
                    if ($printer.PortName -match '\b(?:\d{1,3}\.){3}\d{1,3}\b') {
                        $printerInfo.IPAddress = $matches[0]
                    } else {
                        $printerInfo.IPAddress = "N/D"
                    }
                    
                    $printerInfo.MarcaModelo = "N/D"
                    $printerInfo.RutaRed = if ($printer.PortName -like "*\*") { $printer.PortName } else { "Local" }
                    
                    $printers += $printerInfo
                }
            } else {
                Write-Log "⚠ No se detectaron impresoras configuradas" -Level "WARNING"
            }
        } catch {
            Write-Log "Error al obtener impresoras: $_" -Level "ERROR"
        }
        
        $systemData.Printers = $printers
        
        # 6. SERVICIOS CRÍTICOS
        Write-Log "Verificando servicios críticos..." -Level "INFO"
        $criticalServiceNames = @("wuauserv", "BITS", "Winmgmt", "Spooler", "EventLog", "Dhcp", "Dnscache")
        $serviceStatus = @()
        
        try {
            foreach ($serviceName in $criticalServiceNames) {
                try {
                    $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                    
                    if ($service) {
                        $serviceInfo = [ServiceInfo]::new()
                        $serviceInfo.Name = $serviceName
                        $serviceInfo.DisplayName = $service.DisplayName
                        $serviceInfo.Status = $service.Status.ToString()
                        $serviceInfo.StartType = $service.StartType.ToString()
                        $serviceInfo.IsCritical = "Sí"
                        $serviceInfo.RequiredState = "Running"
                        
                        $serviceStatus += $serviceInfo
                    } else {
                        Write-Log "⚠ Servicio $serviceName no encontrado" -Level "WARNING"
                    }
                } catch {
                    Write-Log "⚠ Error verificando servicio $serviceName" -Level "WARNING"
                }
            }
        } catch {
            Write-Log "Error al verificar servicios: $_" -Level "ERROR"
        }
        
        $systemData.ServiceStatus = $serviceStatus
        
        Show-Progress -PhaseNumber 1 -PhaseName "AUDITORÍA BÁSICA DEL SISTEMA" -Percent 90
        
        # 7. MANTENIMIENTO AUTOMÁTICO (si está habilitado)
        if ($AutoClean) {
            Write-Log "Ejecutando mantenimiento automático..." -Level "INFO"
            
            try {
                $tempFolders = @("$env:TEMP\*", "C:\Windows\Temp\*")
                $cleanedCount = 0
                
                foreach ($folder in $tempFolders) {
                    try {
                        $oldFiles = Get-ChildItem $folder -Recurse -ErrorAction SilentlyContinue | 
                                   Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-7) }
                        
                        if ($oldFiles) {
                            foreach ($file in $oldFiles) {
                                try {
                                    Remove-Item -Path $file.FullName -Recurse -Force -ErrorAction SilentlyContinue
                                    $cleanedCount++
                                } catch {
                                    # Ignorar errores de archivos bloqueados
                                }
                            }
                        }
                    } catch {
                        Write-Log "⚠ Error limpiando carpeta temporal" -Level "WARNING"
                    }
                }
                
                Write-Log "Limpieza completada: $cleanedCount archivos temporales eliminados" -Level "SUCCESS"
            } catch {
                Write-Log "Error en mantenimiento automático: $_" -Level "ERROR"
            }
        }

# 8. GENERAR REPORTE CONSOLIDADO (para esta fase)
        Write-Log "Generando reporte consolidado de Fase 1..." -Level "INFO"
        
        # ✅ CORRECCIÓN: Validar datos antes de calcular estadísticas
        $discoC = $diskData | Where-Object { $_.Disco -eq "C:" } | Select-Object -First 1
        
        $report = [PSCustomObject]@{
            Auditoria_ID = "$ComputerName`_$Timestamp"
            Fecha = $systemInfo.FechaAuditoria
            Equipo = $systemInfo.Hostname
            Usuario = $systemInfo.UsuarioActual
            SO = $systemInfo.SistemaOperativo
            RAM_GB = $systemInfo.RAM_GB
            Procesador = $systemInfo.Procesador
            DiscoC_TamanoGB = if ($discoC) { $discoC.SizeGB } else { 0 }
            DiscoC_LibreGB = if ($discoC) { $discoC.FreeGB } else { 0 }
            DiscoC_Porcentaje = if ($discoC) { $discoC.PercentFree } else { 0 }
            NumeroPerfiles = $userProfiles.Count
            Perfiles_Mayores2GB = ($userProfiles | Where-Object { $_.SizeGB -gt 2 }).Count
            Perfiles_Inactivos30d = ($userProfiles | Where-Object { $_.DaysInactive -gt 30 }).Count
            Perfil_MasGrande = if ($userProfiles.Count -gt 0) { ($userProfiles | Sort-Object SizeGB -Descending | Select-Object -First 1).UserName } else { "N/A" }
            TamanoPerfil_MasGrande = if ($userProfiles.Count -gt 0) { ($userProfiles | Sort-Object SizeGB -Descending | Select-Object -First 1).SizeGB } else { 0 }
            Aplicaciones_Total = $applications.Count
            Impresoras_Totales = $printers.Count
            Impresoras_Compartidas = ($printers | Where-Object { $_.Shared }).Count
            Servicios_Criticos = $serviceStatus.Count
            Servicios_NoEjecutando = ($serviceStatus | Where-Object { $_.Status -ne "Running" }).Count
            Estado_Espacio = if ($discoC) { 
                if ($discoC.PercentFree -lt 20) { "CRITICO" } 
                elseif ($discoC.PercentFree -lt 30) { "ALERTA" } 
                else { "OK" } 
            } else { "NO DETECTADO" }
            Estado_Perfiles = if ($userProfiles.Count -gt 15) { "ALERTA" } else { "OK" }
            Estado_Servicios = if ($serviceStatus.Count -eq 0 -or ($serviceStatus | Where-Object { $_.Status -ne "Running" }).Count -gt 0) { "ALERTA" } else { "OK" }
            Mantenimiento_Ejecutado = $AutoClean
            Observaciones = ""
        }
        
        # Exportar reporte de esta fase
        $fase1ReportFile = Join-Path $phaseFolders[1] "$ComputerName`_Fase1_$Timestamp.csv"
        $report | Export-Csv -Path $fase1ReportFile -NoTypeInformation -Encoding UTF8
        Write-Log "Reporte Fase 1 guardado: $fase1ReportFile" -Level "SUCCESS"
        
        # Crear reporte legible en texto
        $textReport = @"
===================================================
        REPORTE DE AUDITORÍA DEL SISTEMA - FASE 1
===================================================
Auditoría completa diseñada por victor 3,1416
Equipo: $ComputerName
Fecha: $(Get-Date -Format 'dd/MM/yyyy HH:mm:ss')

Fecha: $(Get-Date -Format 'dd/MM/yyyy HH:mm:ss')
Equipo: $ComputerName
Usuario: $($systemInfo.UsuarioActual)
Sistema Operativo: $($systemInfo.SistemaOperativo)

** HARDWARE **
Procesador: $($systemInfo.Procesador)
Nucleos: $($systemInfo.Nucleos)
RAM Total: $($systemInfo.RAM_GB) GB
Fabricante: $($systemInfo.Fabricante)
Modelo: $($systemInfo.Modelo)

** ALMACENAMIENTO **
Disco C: $($report.DiscoC_LibreGB) GB libre de $($report.DiscoC_TamanoGB) GB ($($report.DiscoC_Porcentaje)%)
Estado: $($report.Estado_Espacio)

** PERFILES DE USUARIO **
Total de perfiles: $($report.NumeroPerfiles)
Perfiles >2GB: $($report.Perfiles_Mayores2GB)
Perfiles inactivos >30 días: $($report.Perfiles_Inactivos30d)
Perfil más grande: $($report.Perfil_MasGrande) ($($report.TamanoPerfil_MasGrande) GB)

** SOFTWARE **
Aplicaciones instaladas: $($report.Aplicaciones_Total)
Impresoras configuradas: $($report.Impresoras_Totales)
Servicios críticos: $($report.Servicios_Criticos) (No ejecutando: $($report.Servicios_NoEjecutando))

** RESUMEN DE ESTADO **
Espacio en disco: $($report.Estado_Espacio)
Gestión de perfiles: $($report.Estado_Perfiles)
Servicios del sistema: $($report.Estado_Servicios)

** RECOMENDACIONES **
$(if($report.Estado_Espacio -eq "CRITICO"){"- Liberar espacio en disco C: inmediatamente`n"}else{""})
$(if($report.Perfiles_Mayores2GB -gt 0){"- Revisar perfiles de usuario mayores a 2GB`n"}else{""})
$(if($report.Servicios_NoEjecutando -gt 0){"- Verificar servicios críticos no ejecutándose`n"}else{""})

===================================================
Reporte generado automáticamente
Archivo CSV: $fase1ReportFile
===================================================
"@
        
        $textReportFile = Join-Path $phaseFolders[1] "$ComputerName`_Fase1_$Timestamp.txt"
        $textReport | Out-File -FilePath $textReportFile -Encoding UTF8
        
        Show-Progress -PhaseNumber 1 -PhaseName "AUDITORÍA BÁSICA DEL SISTEMA" -Percent 100
        
        # Mostrar resumen en pantalla
        Write-Host "`n=== RESUMEN FASE 1 ===" -ForegroundColor Cyan
        Write-Host "Auditoría completa diseñada por victor 3,1416" -ForegroundColor DarkGray
        Write-Host "Equipo: $ComputerName | Fecha: $(Get-Date -Format 'dd/MM/yyyy HH:mm')" -ForegroundColor DarkGray
        Write-Host ""
        Write-Host "✓ Equipo: $ComputerName" -ForegroundColor Green
        
        if ($discoC) {
            $color = if ($report.Estado_Espacio -eq "CRITICO") { "Red" } elseif ($report.Estado_Espacio -eq "ALERTA") { "Yellow" } else { "Green" }
            Write-Host "✓ Espacio C: $($report.DiscoC_LibreGB)GB libre ($($report.DiscoC_Porcentaje)%) - $($report.Estado_Espacio)" -ForegroundColor $color
        } else {
            Write-Host "⚠ Disco C: No detectado" -ForegroundColor Yellow
        }
        
        Write-Host "✓ Perfiles: $($report.NumeroPerfiles) totales, $($report.Perfiles_Mayores2GB) >2GB" -ForegroundColor Green
        Write-Host "✓ Servicios: $($report.Servicios_Criticos) críticos, $($report.Servicios_NoEjecutando) no ejecutando" -ForegroundColor Green
        Write-Host ""
        Write-Host "=== ARCHIVOS GENERADOS (FASE 1) ===" -ForegroundColor Green
        Write-Host "* Reporte CSV: $fase1ReportFile"
        Write-Host "* Reporte TXT: $textReportFile"
        
        # Guardar datos en estructura global
        $global:AuditData.Fase1 = $systemData
        
        $fase1Duration = [math]::Round(((Get-Date) - $fase1Start).TotalSeconds, 2)
        Write-Log "Fase 1 (Auditoría Básica) completada en $fase1Duration segundos" -Level "SUCCESS"
        
        return $true
    }
    catch {
        Write-Log "Error en auditoría básica: $_" -Level "ERROR"
        Write-Log "Stack trace: $($_.ScriptStackTrace)" -Level "ERROR"
        return $false
    }
}
#endregion

#region FUNCIONES DE FASE 2 (RECOLECCIÓN DE DATOS)
function Invoke-Fase2 {
    Show-Progress -PhaseNumber 2 -PhaseName "RECOLECCIÓN DE DATOS DEL SISTEMA" -Percent 10
    Show-AuditHeader -Title "FASE 2 - RECOLECCIÓN DE DATOS DEL SISTEMA" -Subtitle "Análisis detallado de hardware y configuración"
    
    Write-Log "Iniciando Fase 2: Recolección de datos del sistema" -Level "INFO"
    $fase2Start = Get-Date
    $fase2Data = @{}
    
    try {
        # 2.1. Obtener información del sistema (actualizada)
        Show-Progress -PhaseNumber 2 -PhaseName "RECOLECCIÓN DE DATOS DEL SISTEMA" -Percent 20
        Write-Log "Obteniendo información del sistema..." -Level "INFO"
        
        $systemInfoF2 = Get-SystemInformationF2
        $fase2Data.SystemInfo = $systemInfoF2
        
        # 2.2. Obtener información de discos (actualizada)
        Show-Progress -PhaseNumber 2 -PhaseName "RECOLECCIÓN DE DATOS DEL SISTEMA" -Percent 40
        Write-Log "Obteniendo información de discos..." -Level "INFO"
        
        $diskInfoF2 = Get-DiskInformationF2
        $fase2Data.DiskInfo = $diskInfoF2
        
        # 2.3. Obtener información de red
        Show-Progress -PhaseNumber 2 -PhaseName "RECOLECCIÓN DE DATOS DEL SISTEMA" -Percent 60
        Write-Log "Obteniendo información de red..." -Level "INFO"
        
        $networkInfoF2 = Get-NetworkInformationF2
        $fase2Data.NetworkInfo = $networkInfoF2
        
        # Guardar datos de esta fase
        $global:AuditData.Fase2 = $fase2Data
        
        # Generar reporte de Fase 2
        Show-Progress -PhaseNumber 2 -PhaseName "RECOLECCIÓN DE DATOS DEL SISTEMA" -Percent 80
        Export-Fase2Reports -SystemInfo $systemInfoF2 -DiskInfo $diskInfoF2 -NetworkInfo $networkInfoF2 `
                           -ComputerName $ComputerName -Timestamp $Timestamp -PhaseFolders $phaseFolders
        
        Show-Progress -PhaseNumber 2 -PhaseName "RECOLECCIÓN DE DATOS DEL SISTEMA" -Percent 100
        $fase2Duration = [math]::Round(((Get-Date) - $fase2Start).TotalSeconds, 2)
        Write-Log "Fase 2 completada en $fase2Duration segundos" -Level "SUCCESS"
        
        return $true
    }
    catch {
        Write-Log "Error en Fase 2: $_" -Level "ERROR"
        return $false
    }
}

function Get-SystemInformationF2 {
    [CmdletBinding()]
    param()
    
    Write-Log "Obteniendo información del sistema (Fase 2)..." -Level "INFO"
    
    $systemInfo = [SystemInfo]::new()
    $uptime = "N/A"
    
    try {
        # ✅ CORRECCIÓN: Usar Get-ComputerInfo con manejo de errores robusto
        try {
            $computerInfo = Get-ComputerInfo -ErrorAction Stop
            
            $systemInfo.ComputerName = $env:COMPUTERNAME
            $systemInfo.Domain = if ($computerInfo.CsDomain) { $computerInfo.CsDomain } else { $env:USERDOMAIN }
            $systemInfo.Workgroup = if ($computerInfo.CsWorkgroup) { $computerInfo.CsWorkgroup } else { "N/A" }
            $systemInfo.OSName = if ($computerInfo.WindowsProductName) { $computerInfo.WindowsProductName } else { $computerInfo.OsName }
            $systemInfo.OSVersion = if ($computerInfo.WindowsVersion) { $computerInfo.WindowsVersion } else { $computerInfo.OsVersion }
            $systemInfo.OSBuild = if ($computerInfo.WindowsBuildLabEx) { $computerInfo.WindowsBuildLabEx } else { $computerInfo.OsBuildNumber }
            $systemInfo.InstallDate = if ($computerInfo.OsInstallDate) { $computerInfo.OsInstallDate.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
            $systemInfo.TimeZone = (Get-TimeZone).Id
            $systemInfo.LastBoot = if ($computerInfo.OsLastBootUpTime) { $computerInfo.OsLastBootUpTime.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
            
            # Calcular uptime
            if ($computerInfo.OsLastBootUpTime -and ($computerInfo.OsLastBootUpTime -is [DateTime])) {
                $uptime = [math]::Round((New-TimeSpan -Start $computerInfo.OsLastBootUpTime -End (Get-Date)).TotalHours, 2)
            }
            
            $systemInfo.UptimeHours = $uptime.ToString()
            
            $systemInfo.Locale = (Get-Culture).Name
            
            # ✅ CORRECCIÓN: Manejo seguro de distribución de teclado
            try {
                $langList = Get-WinUserLanguageList -ErrorAction SilentlyContinue
                if ($langList -and $langList.Count -gt 0 -and $langList[0].InputMethodTips) {
                    $systemInfo.KeyboardLayout = $langList[0].InputMethodTips[0]
                } else {
                    $systemInfo.KeyboardLayout = "N/A"
                }
            } catch {
                $systemInfo.KeyboardLayout = "N/A"
            }
            
            # Hardware adicional
            $systemInfo.Fabricante = if ($computerInfo.CsManufacturer) { $computerInfo.CsManufacturer } else { "N/A" }
            $systemInfo.Modelo = if ($computerInfo.CsModel) { $computerInfo.CsModel } else { "N/A" }
            $systemInfo.RAM_GB = if ($computerInfo.CsTotalPhysicalMemory) { 
                [math]::Round($computerInfo.CsTotalPhysicalMemory / 1GB, 2) 
            } else { 0 }
            
            $systemInfo.Procesador = if ($computerInfo.CsProcessors) { 
                $computerInfo.CsProcessors[0].Name 
            } else { "N/A" }
            
            $systemInfo.Nucleos = if ($computerInfo.CsNumberOfProcessors -and $computerInfo.CsNumberOfLogicalProcessors) { 
                "$($computerInfo.CsNumberOfProcessors)/$($computerInfo.CsNumberOfLogicalProcessors)" 
            } else { "N/A" }
            
            # Número de serie del BIOS
            $systemInfo.NumeroSerie = if ($computerInfo.BiosSeralNumber) { 
                $computerInfo.BiosSeralNumber 
            } else { 
                try {
                    $bios = Get-CimInstance Win32_BIOS -ErrorAction SilentlyContinue
                    if ($bios) { $bios.SerialNumber } else { "N/A" }
                } catch { "N/A" }
            }
            
            Write-Log "Información del sistema recolectada (Fase 2)" -Level "SUCCESS"
            
        } catch {
            # ✅ Fallback: Si Get-ComputerInfo falla, usar métodos alternativos
            Write-Log "⚠ Get-ComputerInfo no disponible, usando métodos alternativos..." -Level "WARNING"
            
            $systemInfo.ComputerName = $env:COMPUTERNAME
            $systemInfo.Domain = $env:USERDOMAIN
            $systemInfo.Workgroup = "N/A"
            
            # Usar WMI como respaldo
            $osInfo = Get-CimInstance Win32_OperatingSystem -ErrorAction SilentlyContinue
            $computerSystem = Get-CimInstance Win32_ComputerSystem -ErrorAction SilentlyContinue
            $bios = Get-CimInstance Win32_BIOS -ErrorAction SilentlyContinue
            $processor = Get-CimInstance Win32_Processor -ErrorAction SilentlyContinue | Select-Object -First 1
            
            if ($osInfo) {
                $systemInfo.OSName = $osInfo.Caption
                $systemInfo.OSVersion = $osInfo.Version
                $systemInfo.OSBuild = $osInfo.BuildNumber
                $systemInfo.InstallDate = $osInfo.InstallDate.ToString("yyyy-MM-dd HH:mm:ss")
                $systemInfo.LastBoot = $osInfo.LastBootUpTime.ToString("yyyy-MM-dd HH:mm:ss")
                $systemInfo.UptimeHours = [math]::Round(((Get-Date) - $osInfo.LastBootUpTime).TotalHours, 2).ToString()
            }
            
            if ($computerSystem) {
                $systemInfo.Fabricante = $computerSystem.Manufacturer
                $systemInfo.Modelo = $computerSystem.Model
                $systemInfo.RAM_GB = [math]::Round($computerSystem.TotalPhysicalMemory / 1GB, 2)
            }
            
            if ($bios) {
                $systemInfo.NumeroSerie = $bios.SerialNumber
            }
            
            if ($processor) {
                $systemInfo.Procesador = $processor.Name
                $systemInfo.Nucleos = "$($processor.NumberOfCores)/$($processor.NumberOfLogicalProcessors)"
            }
            
            $systemInfo.TimeZone = (Get-TimeZone).Id
            $systemInfo.Locale = (Get-Culture).Name
            $systemInfo.KeyboardLayout = "N/A"
        }
        
        # Propiedades compatibles (copiar valores)
        $systemInfo.Hostname = $systemInfo.ComputerName
        $systemInfo.UsuarioActual = $env:USERNAME
        $systemInfo.Dominio = $systemInfo.Domain
        $systemInfo.SistemaOperativo = $systemInfo.OSName
        $systemInfo.VersionOS = $systemInfo.OSVersion
        $systemInfo.Arquitectura = if ([Environment]::Is64BitOperatingSystem) { "64-bit" } else { "32-bit" }
        $systemInfo.UltimoArranque = $systemInfo.LastBoot
        $systemInfo.TiempoActividad = $systemInfo.UptimeHours
        $systemInfo.FechaAuditoria = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        
    }
    catch {
        Write-Log "ERROR obteniendo información del sistema (Fase 2): $_" -Level "ERROR"
        
        # Asignar valores por defecto en caso de error crítico
        $systemInfo.ComputerName = $env:COMPUTERNAME
        $systemInfo.Hostname = $env:COMPUTERNAME
        $systemInfo.UsuarioActual = $env:USERNAME
        $systemInfo.Dominio = $env:USERDOMAIN
        $systemInfo.OSName = "Windows (versión no detectada)"
        $systemInfo.OSVersion = "N/A"
        $systemInfo.UptimeHours = "N/A"
        $systemInfo.FechaAuditoria = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    
    return $systemInfo
}

function Get-DiskInformationF2 {
    [CmdletBinding()]
    param()
    
    Write-Log "Obteniendo información de discos (Fase 2)..." -Level "INFO"
    
    # Limpiar caché de PowerShell
    Get-PSDrive | Out-Null
    
    # Array para SOLO discos válidos
    $validDisks = @()
    
    try {
        # ✅ CORRECCIÓN: Intentar primero con Get-Disk, si falla usar WMI
        $allDisks = $null
        
        try {
            $allDisks = Get-Disk -ErrorAction Stop
        } catch {
            Write-Log "⚠ Get-Disk no disponible, usando método alternativo WMI..." -Level "WARNING"
            
            # Fallback: Usar WMI/CIM para obtener discos lógicos
            $logicalDisks = Get-CimInstance Win32_LogicalDisk -ErrorAction SilentlyContinue
            
            if ($logicalDisks) {
                foreach ($disk in $logicalDisks) {
                    if ($disk.Size -gt 0) {
                        $diskInfo = [DiskInfo]::new()
                        $diskInfo.Disco = $disk.DeviceID
                        $diskInfo.Tipo = switch ($disk.DriveType) {
                            2 { "Removible" }
                            3 { "Local" }
                            4 { "Red" }
                            5 { "CD-ROM" }
                            default { "Desconocido" }
                        }
                        $diskInfo.Model = if ($disk.VolumeName) { $disk.VolumeName } else { "Sin nombre" }
                        $diskInfo.Serial = "N/A"
                        $diskInfo.SizeGB = [math]::Round($disk.Size / 1GB, 2)
                        $diskInfo.FreeGB = [math]::Round($disk.FreeSpace / 1GB, 2)
                        $diskInfo.PercentFree = [math]::Round(($disk.FreeSpace / $disk.Size) * 100, 2)
                        $diskInfo.SistemaArchivos = if ($disk.FileSystem) { $disk.FileSystem } else { "N/A" }
                        $diskInfo.HealthStatus = "N/A (WMI)"
                        $diskInfo.Temperature = "N/A"
                        
                        $validDisks += $diskInfo
                    }
                }
                
                Write-Log "✓ Método WMI: $($validDisks.Count) discos detectados" -Level "SUCCESS"
                return ,$validDisks
            }
        }
        
        # Si llegamos aquí, Get-Disk funcionó
        if (-not $allDisks) {
            Write-Log "No se detectaron discos en el sistema" -Level "WARNING"
            
            # Crear UN disco placeholder si no hay NINGUNO
            $placeholder = [DiskInfo]::new()
            $placeholder.Disco = "Sin discos detectados"
            $placeholder.Tipo = "N/A"
            $placeholder.Model = "Sistema sin discos físicos"
            $placeholder.Serial = "N/A"
            $placeholder.SizeGB = 0
            $placeholder.FreeGB = 0
            $placeholder.PercentFree = 0
            $placeholder.HealthStatus = "N/A"
            $placeholder.Temperature = "N/A"
            $placeholder.SistemaArchivos = "N/A"
            
            return ,$placeholder
        }
        
        $totalDetected = @($allDisks).Count
        Write-Log "Discos físicos detectados por Windows: $totalDetected" -Level "INFO"
        
        # FILTRAR: Solo procesar discos que cumplan TODOS los criterios
        foreach ($disk in $allDisks) {
            
            # ❌ SALTAR si no cumple criterios mínimos
            if (-not $disk) {
                Write-Log "Disco null ignorado" -Level "WARNING"
                continue
            }
            
            if ($null -eq $disk.Number) {
                Write-Log "Disco sin número ignorado" -Level "WARNING"
                continue
            }
            
            if ($disk.Size -le 0) {
                Write-Log "Disco $($disk.Number) ignorado: Sin tamaño (Size=$($disk.Size))" -Level "WARNING"
                continue
            }
            
            # ✅ ESTE DISCO ES VÁLIDO - Procesar
            $diskInfo = [DiskInfo]::new()
            
            $diskInfo.Disco = "Disk $($disk.Number)"
            $diskInfo.Tipo = if ($disk.BusType) { $disk.BusType.ToString() } else { "Desconocido" }
            $diskInfo.Model = if ($disk.Model) { $disk.Model.Trim() } else { "Modelo no identificado" }
            $diskInfo.Serial = if ($disk.SerialNumber) { $disk.SerialNumber.Trim() } else { "Serial no disponible" }
            
            # Cálculo de tamaños (ya sabemos que Size > 0)
            $diskInfo.SizeGB = [math]::Round($disk.Size / 1GB, 2)
            
            # ✅ CORRECCIÓN: Obtener espacio libre REAL de las particiones del disco
            try {
                $partitions = Get-Partition -DiskNumber $disk.Number -ErrorAction SilentlyContinue
                $totalFree = 0
                $hasPartitions = $false
                $fileSystem = "N/A"
                
                foreach ($partition in $partitions) {
                    if ($partition.DriveLetter) {
                        $hasPartitions = $true
                        $volume = Get-Volume -DriveLetter $partition.DriveLetter -ErrorAction SilentlyContinue
                        if ($volume) {
                            if ($volume.SizeRemaining) {
                                $totalFree += $volume.SizeRemaining
                            }
                            if ($volume.FileSystem -and $fileSystem -eq "N/A") {
                                $fileSystem = $volume.FileSystem
                            }
                        }
                    }
                }
                
                if ($hasPartitions) {
                    # Espacio libre de particiones montadas
                    $diskInfo.FreeGB = [math]::Round($totalFree / 1GB, 2)
                    $diskInfo.SistemaArchivos = $fileSystem
                } else {
                    # Sin particiones montadas - calcular desde AllocatedSize
                    $allocated = if ($disk.AllocatedSize) { $disk.AllocatedSize } else { 0 }
                    $diskInfo.FreeGB = [math]::Round(($disk.Size - $allocated) / 1GB, 2)
                    $diskInfo.SistemaArchivos = "Sin particiones"
                }
                
                # Calcular porcentaje libre
                if ($diskInfo.SizeGB -gt 0) {
                    $diskInfo.PercentFree = [math]::Round(($diskInfo.FreeGB / $diskInfo.SizeGB) * 100, 2)
                } else {
                    $diskInfo.PercentFree = 0
                }
            }
            catch {
                # Error al obtener particiones - usar cálculo básico
                $allocated = if ($disk.AllocatedSize) { $disk.AllocatedSize } else { $disk.Size }
                $diskInfo.FreeGB = [math]::Round(($disk.Size - $allocated) / 1GB, 2)
                $diskInfo.PercentFree = 0
                $diskInfo.SistemaArchivos = "Error al detectar"
                Write-Log "Advertencia: No se pudo calcular espacio libre exacto para Disco $($disk.Number)" -Level "WARNING"
            }
            
            # ✅ CORRECCIÓN: Información física (SMART, temperatura, estado)
            try {
                $physicalDisk = Get-PhysicalDisk -DeviceNumber $disk.Number -ErrorAction SilentlyContinue
                
                if ($physicalDisk) {
                    $diskInfo.HealthStatus = if ($physicalDisk.HealthStatus) { 
                        $physicalDisk.HealthStatus.ToString() 
                    } else { 
                        "Estado desconocido" 
                    }
                    
                    # Temperatura (solo si está disponible y es válida)
                    if ($physicalDisk.Temperature -and $physicalDisk.Temperature -gt 0 -and $physicalDisk.Temperature -lt 100) { 
                        $diskInfo.Temperature = "$($physicalDisk.Temperature)°C" 
                    } else { 
                        $diskInfo.Temperature = "No disponible" 
                    }
                } else {
                    $diskInfo.HealthStatus = "Información SMART no accesible"
                    $diskInfo.Temperature = "N/A"
                }
            }
            catch {
                $diskInfo.HealthStatus = "Error al consultar estado"
                $diskInfo.Temperature = "N/A"
            }
            
            # ✅ AGREGAR solo si llegó hasta aquí
            $validDisks += $diskInfo
            Write-Log "✓ Disco $($disk.Number) VÁLIDO: $($diskInfo.Model) - $($diskInfo.SizeGB) GB" -Level "INFO"
        }
        
        # RESULTADO FINAL
        if ($validDisks.Count -eq 0) {
            Write-Log "⚠ No se encontraron discos válidos/accesibles" -Level "WARNING"
            
            # Crear un placeholder indicando que hay discos pero no son accesibles
            $noValid = [DiskInfo]::new()
            $noValid.Disco = "Discos no accesibles"
            $noValid.Tipo = "Detectados pero inaccesibles"
            $noValid.Model = "Windows detectó $totalDetected disco(s) pero ninguno es accesible"
            $noValid.Serial = "N/A"
            $noValid.SizeGB = 0
            $noValid.FreeGB = 0
            $noValid.PercentFree = 0
            $noValid.HealthStatus = "No accesible"
            $noValid.Temperature = "N/A"
            $noValid.SistemaArchivos = "N/A"
            
            return ,$noValid
        }
        
        Write-Log "✓ Total discos VÁLIDOS procesados: $($validDisks.Count) de $totalDetected" -Level "SUCCESS"
        return ,$validDisks  # La coma fuerza array
        
    }
    catch {
        Write-Log "ERROR en Get-DiskInformation (Fase 2): $_" -Level "ERROR"
        
        # Disco de error
        $errorDisk = [DiskInfo]::new()
        $errorDisk.Disco = "Error crítico"
        $errorDisk.Tipo = "Error"
        $errorDisk.Model = "Error al escanear discos: $_"
        $errorDisk.Serial = "N/A"
        $errorDisk.SizeGB = 0
        $errorDisk.FreeGB = 0
        $errorDisk.PercentFree = 0
        $errorDisk.HealthStatus = "Error"
        $errorDisk.Temperature = "N/A"
        $errorDisk.SistemaArchivos = "N/A"
        
        return ,$errorDisk
    }
}

function Get-NetworkInformationF2 {
    [CmdletBinding()]
    param()
    
    Write-Log "Obteniendo información de red (Fase 2)..." -Level "INFO"
    
    $networkInfo = @{
        Interfaces = @()
        IPAddresses = @()
        DNS = @()
        Gateway = @()
        FechaRecoleccion = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    }
    
    try {
        # Obtener adaptadores de red (incluyendo todos, no solo los activos)
        $adapters = Get-NetAdapter -ErrorAction SilentlyContinue
        
        if (-not $adapters -or $adapters.Count -eq 0) {
            Write-Log "No se detectaron adaptadores de red" -Level "WARNING"
            $networkInfo.Interfaces += @{
                Name = "Sin adaptadores"
                Description = "No se detectaron interfaces de red"
                MAC = "00:00:00:00:00:00"
                Status = "No disponible"
                Speed = "N/A"
            }
        } else {
            Write-Log "Se encontraron $($adapters.Count) adaptadores de red" -Level "INFO"
            
            foreach ($adapter in $adapters) {
                $interfaceInfo = @{
                    Name = $adapter.Name
                    Description = if ($adapter.InterfaceDescription) { $adapter.InterfaceDescription } else { "Sin descripción" }
                    MAC = if ($adapter.MacAddress) { $adapter.MacAddress } else { "No disponible" }
                    Status = $adapter.Status.ToString()
                    Speed = if ($adapter.LinkSpeed) { $adapter.LinkSpeed } else { "N/A" }
                }
                
                $networkInfo.Interfaces += $interfaceInfo
                
                # Obtener configuración IP solo para adaptadores conectados
                if ($adapter.Status -eq "Up") {
                    try {
                        $ipConfig = Get-NetIPConfiguration -InterfaceIndex $adapter.InterfaceIndex -ErrorAction SilentlyContinue
                        
                        if ($ipConfig) {
                            # Direcciones IPv4
                            if ($ipConfig.IPv4Address) {
                                foreach ($ip in $ipConfig.IPv4Address) {
                                    if ($ip.IPAddress -and $networkInfo.IPAddresses -notcontains $ip.IPAddress) {
                                        $networkInfo.IPAddresses += $ip.IPAddress
                                    }
                                }
                            }
                            
                            # Servidores DNS
                            if ($ipConfig.DNSServer) {
                                foreach ($dns in $ipConfig.DNSServer) {
                                    if ($dns.ServerAddresses) {
                                        foreach ($dnsAddr in $dns.ServerAddresses) {
                                            if ($dnsAddr -and $networkInfo.DNS -notcontains $dnsAddr) {
                                                $networkInfo.DNS += $dnsAddr
                                            }
                                        }
                                    }
                                }
                            }
                            
                            # Gateway
                            if ($ipConfig.IPv4DefaultGateway) {
                                foreach ($gw in $ipConfig.IPv4DefaultGateway) {
                                    if ($gw.NextHop -and $networkInfo.Gateway -notcontains $gw.NextHop) {
                                        $networkInfo.Gateway += $gw.NextHop
                                    }
                                }
                            }
                        }
                    }
                    catch {
                        Write-Log "No se pudo obtener configuración IP para $($adapter.Name): $_" -Level "WARNING"
                    }
                }
            }
        }
        
        # Si no hay direcciones IP, agregar una indicación
        if ($networkInfo.IPAddresses.Count -eq 0) {
            $networkInfo.IPAddresses += "No se detectaron direcciones IP activas"
        }
        
        Write-Log "Información de red recolectada: $($networkInfo.Interfaces.Count) interfaces, $($networkInfo.IPAddresses.Count) IPs" -Level "SUCCESS"
    }
    catch {
        Write-Log "ERROR obteniendo información de red: $_" -Level "ERROR"
        # Mantener estructura básica incluso en error
        $networkInfo.Interfaces += @{
            Name = "Error en detección"
            Description = "No se pudo obtener información de red"
            MAC = "00:00:00:00:00:00"
            Status = "Error"
            Speed = "N/A"
        }
        $networkInfo.IPAddresses += "Error al obtener configuración IP"
    }
    
    return $networkInfo
}

function Export-Fase2Reports {
    [CmdletBinding()]
    param(
        [object]$SystemInfo,
        [array]$DiskInfo,
        [hashtable]$NetworkInfo,
        [string]$ComputerName,
        [string]$Timestamp,
        [hashtable]$PhaseFolders
    )
    
    Write-Log "Generando reportes de Fase 2..." -Level "INFO"
    
    try {
        # 1. Reporte CSV para Fase 2
        $csvData = @()
        
        # Encabezado de auditoría
        $csvData += [PSCustomObject]@{
            Seccion = "AUDITORIA"
            Propiedad = "Diseñado por"
            Valor = "victor 3,1416"
        }
        
        $csvData += [PSCustomObject]@{
            Seccion = "AUDITORIA"
            Propiedad = "Equipo"
            Valor = $ComputerName
        }
        
        $csvData += [PSCustomObject]@{
            Seccion = "AUDITORIA"
            Propiedad = "Fecha y hora"
            Valor = (Get-Date -Format "dd/MM/yyyy HH:mm:ss")
        }
        
        # ✅ CORRECCIÓN: Validar que SystemInfo existe antes de acceder
        if ($SystemInfo) {
            # Información del sistema
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Nombre del Equipo"
                Valor = if ($SystemInfo.ComputerName) { $SystemInfo.ComputerName } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Sistema Operativo"
                Valor = if ($SystemInfo.OSName -and $SystemInfo.OSVersion) { "$($SystemInfo.OSName) $($SystemInfo.OSVersion)" } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Build del SO"
                Valor = if ($SystemInfo.OSBuild) { $SystemInfo.OSBuild } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Dominio/Grupo de Trabajo"
                Valor = "$($SystemInfo.Domain)/$($SystemInfo.Workgroup)"
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Fecha de Instalación"
                Valor = if ($SystemInfo.InstallDate) { $SystemInfo.InstallDate } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Último Arranque"
                Valor = if ($SystemInfo.LastBoot) { $SystemInfo.LastBoot } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Tiempo de Actividad (horas)"
                Valor = if ($SystemInfo.UptimeHours) { $SystemInfo.UptimeHours } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Zona Horaria"
                Valor = if ($SystemInfo.TimeZone) { $SystemInfo.TimeZone } else { "N/A" }
            }
            
            $csvData += [PSCustomObject]@{
                Seccion = "SISTEMA"
                Propiedad = "Configuración Regional"
                Valor = if ($SystemInfo.Locale) { $SystemInfo.Locale } else { "N/A" }
            }
        }
        
        # Separador
        $csvData += [PSCustomObject]@{
            Seccion = ""
            Propiedad = ""
            Valor = ""
        }
        
        # Discos
        if ($DiskInfo -and $DiskInfo.Count -gt 0) {
            $csvData += [PSCustomObject]@{
                Seccion = "DISCOS"
                Propiedad = "Número de Discos Detectados"
                Valor = $DiskInfo.Count
            }
            
            foreach ($disk in $DiskInfo) {
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "Disco: $($disk.Disco)"
                    Valor = "Modelo: $($disk.Model)"
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "  Tipo"
                    Valor = $disk.Tipo
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "  Tamaño Total"
                    Valor = "$($disk.SizeGB) GB"
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "  Espacio Libre"
                    Valor = "$($disk.FreeGB) GB ($($disk.PercentFree)%)"
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "  Estado de Salud"
                    Valor = $disk.HealthStatus
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "  Temperatura"
                    Valor = $disk.Temperature
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "DISCOS"
                    Propiedad = "  Número de Serie"
                    Valor = $disk.Serial
                }
            }
        }
        
        # Separador
        $csvData += [PSCustomObject]@{
            Seccion = ""
            Propiedad = ""
            Valor = ""
        }
        
        # Red
        if ($NetworkInfo -and $NetworkInfo.Interfaces -and $NetworkInfo.Interfaces.Count -gt 0) {
            $csvData += [PSCustomObject]@{
                Seccion = "RED"
                Propiedad = "Interfaces de Red Detectadas"
                Valor = $NetworkInfo.Interfaces.Count
            }
            
            foreach ($interface in $NetworkInfo.Interfaces) {
                $csvData += [PSCustomObject]@{
                    Seccion = "RED"
                    Propiedad = "Interfaz: $($interface.Name)"
                    Valor = $interface.Description
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "RED"
                    Propiedad = "  Estado"
                    Valor = $interface.Status
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "RED"
                    Propiedad = "  Velocidad"
                    Valor = $interface.Speed
                }
                
                $csvData += [PSCustomObject]@{
                    Seccion = "RED"
                    Propiedad = "  Dirección MAC"
                    Valor = $interface.MAC
                }
            }
            
            # Direcciones IP
            if ($NetworkInfo.IPAddresses -and $NetworkInfo.IPAddresses.Count -gt 0) {
                $csvData += [PSCustomObject]@{
                    Seccion = "RED"
                    Propiedad = "Direcciones IP Activas"
                    Valor = ($NetworkInfo.IPAddresses -join ", ")
                }
            }
        }
        
        # Exportar CSV
        $fase2CSV = Join-Path $PhaseFolders[2] "$ComputerName`_Fase2_$Timestamp.csv"
        $csvData | Export-Csv -Path $fase2CSV -NoTypeInformation -Encoding UTF8 -Delimiter ","
        Write-Log "Reporte CSV Fase 2 guardado: $fase2CSV" -Level "SUCCESS"
        
        # 2. Reporte resumen en consola
        Write-Host "`n=== RESUMEN FASE 2 ===" -ForegroundColor Cyan
        Write-Host "Auditoría completa diseñada por victor 3,1416" -ForegroundColor DarkGray
        Write-Host "Equipo: $ComputerName | Fecha: $(Get-Date -Format 'dd/MM/yyyy HH:mm')" -ForegroundColor DarkGray
        Write-Host ""
        
        if ($SystemInfo) {
            Write-Host "✓ Sistema: $($SystemInfo.ComputerName)" -ForegroundColor Green
            Write-Host "✓ SO: $($SystemInfo.OSName) $($SystemInfo.OSVersion)" -ForegroundColor Green
            Write-Host "✓ Uptime: $($SystemInfo.UptimeHours) horas" -ForegroundColor Green
            Write-Host "✓ Dominio/Grupo: $($SystemInfo.Domain)/$($SystemInfo.Workgroup)" -ForegroundColor Cyan
        }
        
        Write-Host "`n✓ Discos detectados: $($DiskInfo.Count)" -ForegroundColor Green
        foreach ($disk in $DiskInfo) {
            if ([double]$disk.SizeGB -gt 0) {
                Write-Host "  - $($disk.Disco): $($disk.SizeGB) GB ($($disk.PercentFree)% libre) [$($disk.Model)]" -ForegroundColor Cyan
            } else {
                Write-Host "  - $($disk.Disco): $($disk.Model) [$($disk.Tipo)]" -ForegroundColor Yellow
            }
        }
        
        if ($NetworkInfo -and $NetworkInfo.Interfaces) {
            Write-Host "`n✓ Interfaces detectadas: $($NetworkInfo.Interfaces.Count)" -ForegroundColor Green
            foreach ($interface in $NetworkInfo.Interfaces) {
                $statusColor = if ($interface.Status -eq "Up") { "Green" } else { "DarkGray" }
                Write-Host "  - $($interface.Name): $($interface.Status) ($($interface.Speed))" -ForegroundColor $statusColor
            }
            
            if ($NetworkInfo.IPAddresses -and $NetworkInfo.IPAddresses.Count -gt 0) {
                Write-Host "✓ Direcciones IP activas: $($NetworkInfo.IPAddresses -join ', ')" -ForegroundColor Cyan
            }
        }
        
        return $true
    }
    catch {
        Write-Log "Error generando reportes Fase 2: $_" -Level "ERROR"
        return $false
    }
}
#endregion

#region FUNCIONES DE FASE 3 (EXPORTACIÓN DE DATOS)

function Invoke-Fase3 {
    param(
        [hashtable]$SystemInfo,
        [array]$Disks,
        [hashtable]$NetworkInfo,
        [string]$ComputerName,
        [string]$Timestamp,
        [hashtable]$PhaseFolders,
        [switch]$ExportHTML
    )
    
    try {
        Show-Progress -Etapa "FASE 3" -Porcentaje 60 -Mensaje "Iniciando exportación de datos..."
        Write-Log -Message "Iniciando FASE 3: Exportación de datos" -Level INFO
        
        # Variables para almacenar resultados
        $results = @{
            CSV = $false
            JSON = $false
            HTML = $false
            Markdown = $false
        }
        
        # Variables para rutas de archivos generados
        $exportFiles = @{
            CSV = $null
            JSON = $null
            HTML = $null
            Markdown = $null
        }
        
        # 1. Exportar a CSV
        Show-Progress -Etapa "FASE 3" -Porcentaje 65 -Mensaje "Exportando datos a CSV..."
        Write-Log -Message "Ejecutando Export-ToCSV..." -Level INFO
        $csvResult = Export-ToCSV -SystemInfo $SystemInfo -Disks $Disks -NetworkInfo $NetworkInfo `
                                 -ComputerName $ComputerName -Timestamp $Timestamp -PhaseFolders $PhaseFolders
        
        if ($csvResult) {
            $results.CSV = $true
            $exportFiles.CSV = $csvResult
            Write-Log -Message "Exportación CSV completada exitosamente: $csvResult" -Level SUCCESS
        } else {
            Write-Log -Message "Fallo en exportación CSV" -Level ERROR
        }
        
        # 2. Exportar a JSON
        Show-Progress -Etapa "FASE 3" -Porcentaje 70 -Mensaje "Exportando datos a JSON..."
        Write-Log -Message "Ejecutando Export-ToJSON..." -Level INFO
        $jsonResult = Export-ToJSON -SystemInfo $SystemInfo -Disks $Disks -NetworkInfo $NetworkInfo `
                                   -ComputerName $ComputerName -Timestamp $Timestamp -PhaseFolders $PhaseFolders
        
        if ($jsonResult) {
            $results.JSON = $true
            $exportFiles.JSON = $jsonResult
            Write-Log -Message "Exportación JSON completada exitosamente: $jsonResult" -Level SUCCESS
        } else {
            Write-Log -Message "Fallo en exportación JSON" -Level ERROR
        }
        
        # 3. Exportar a HTML (condicional)
        if ($ExportHTML) {
            Show-Progress -Etapa "FASE 3" -Porcentaje 75 -Mensaje "Exportando datos a HTML..."
            Write-Log -Message "Ejecutando Export-ToHTML..." -Level INFO
            $htmlResult = Export-ToHTML -SystemInfo $SystemInfo -Disks $Disks -NetworkInfo $NetworkInfo `
                                       -ComputerName $ComputerName -Timestamp $Timestamp -PhaseFolders $PhaseFolders
            
            if ($htmlResult) {
                $results.HTML = $true
                $exportFiles.HTML = $htmlResult
                Write-Log -Message "Exportación HTML completada exitosamente: $htmlResult" -Level SUCCESS
            } else {
                Write-Log -Message "Fallo en exportación HTML" -Level ERROR
            }
        } else {
            Write-Log -Message "Exportación HTML omitida (ExportHTML = `$false)" -Level INFO
        }
        
        # 4. Exportar a Markdown
        Show-Progress -Etapa "FASE 3" -Porcentaje 80 -Mensaje "Exportando datos a Markdown..."
        Write-Log -Message "Ejecutando Export-ToMarkdown..." -Level INFO
        $mdResult = Export-ToMarkdown -SystemInfo $SystemInfo -Disks $Disks -NetworkInfo $NetworkInfo `
                                     -ComputerName $ComputerName -Timestamp $Timestamp -PhaseFolders $PhaseFolders
        
        if ($mdResult) {
            $results.Markdown = $true
            $exportFiles.Markdown = $mdResult
            Write-Log -Message "Exportación Markdown completada exitosamente: $mdResult" -Level SUCCESS
        } else {
            Write-Log -Message "Fallo en exportación Markdown" -Level ERROR
        }
        
        # Resumen de resultados
        $successCount = ($results.CSV, $results.JSON, $results.Markdown).Count -eq $true
        if ($ExportHTML) {
            $successCount += $results.HTML
        }
        
        Show-Progress -Etapa "FASE 3" -Porcentaje 85 -Mensaje "Exportación completada"
        Write-Log -Message "FASE 3 completada: $successCount formatos exportados exitosamente" -Level SUCCESS
        
        return @{
            Results = $results
            Files = $exportFiles
        }
        
    } catch {
        Write-Log -Message "Error crítico en Invoke-Fase3: $_" -Level ERROR
        Write-Log -Message "Stack trace: $($_.ScriptStackTrace)" -Level ERROR
        return $false
    }
}

function Export-ToCSV {
    param(
        [hashtable]$SystemInfo,
        [array]$Disks,
        [hashtable]$NetworkInfo,
        [string]$ComputerName,
        [string]$Timestamp,
        [hashtable]$PhaseFolders
    )
    
    try {
        # Validación de datos
        if (-not $SystemInfo -or -not $Disks -or -not $NetworkInfo) {
            Write-Log -Message "Datos insuficientes para exportar a CSV" -Level ERROR
            return $null
        }
        
        # Preparar datos para CSV
        $csvData = @()
        
        # 1. Información del sistema
        $systemRow = [PSCustomObject]@{
            "Seccion" = "Sistema"
            "Propiedad" = "Nombre del Equipo"
            "Valor" = $SystemInfo.ComputerName
            "Timestamp" = $Timestamp
        }
        $csvData += $systemRow
        
        $systemRow = [PSCustomObject]@{
            "Seccion" = "Sistema"
            "Propiedad" = "Sistema Operativo"
            "Valor" = $SystemInfo.OSName
            "Timestamp" = $Timestamp
        }
        $csvData += $systemRow
        
        $systemRow = [PSCustomObject]@{
            "Seccion" = "Sistema"
            "Propiedad" = "Arquitectura"
            "Valor" = $SystemInfo.OSArchitecture
            "Timestamp" = $Timestamp
        }
        $csvData += $systemRow
        
        $systemRow = [PSCustomObject]@{
            "Seccion" = "Sistema"
            "Propiedad" = "Memoria Total (GB)"
            "Valor" = $SystemInfo.TotalMemoryGB
            "Timestamp" = $Timestamp
        }
        $csvData += $systemRow
        
        # 2. Discos
        foreach ($disk in $Disks) {
            $diskRow = [PSCustomObject]@{
                "Seccion" = "Disco"
                "Propiedad" = "Letra de Unidad"
                "Valor" = $disk.DriveLetter
                "Timestamp" = $Timestamp
            }
            $csvData += $diskRow
            
            $diskRow = [PSCustomObject]@{
                "Seccion" = "Disco"
                "Propiedad" = "Tamaño Total (GB)"
                "Valor" = $disk.TotalSizeGB
                "Timestamp" = $Timestamp
            }
            $csvData += $diskRow
            
            $diskRow = [PSCustomObject]@{
                "Seccion" = "Disco"
                "Propiedad" = "Espacio Libre (GB)"
                "Valor" = $disk.FreeSpaceGB
                "Timestamp" = $Timestamp
            }
            $csvData += $diskRow
            
            $diskRow = [PSCustomObject]@{
                "Seccion" = "Disco"
                "Propiedad" = "Porcentaje Libre"
                "Valor" = $disk.FreeSpacePercent
                "Timestamp" = $Timestamp
            }
            $csvData += $diskRow
        }
        
        # 3. Información de red
        $netRow = [PSCustomObject]@{
            "Seccion" = "Red"
            "Propiedad" = "Hostname"
            "Valor" = $NetworkInfo.Hostname
            "Timestamp" = $Timestamp
        }
        $csvData += $netRow
        
        $netRow = [PSCustomObject]@{
            "Seccion" = "Red"
            "Propiedad" = "Dirección IP"
            "Valor" = $NetworkInfo.IPAddress
            "Timestamp" = $Timestamp
        }
        $csvData += $netRow
        
        $netRow = [PSCustomObject]@{
            "Seccion" = "Red"
            "Propiedad" = "Máscara de Subred"
            "Valor" = $NetworkInfo.SubnetMask
            "Timestamp" = $Timestamp
        }
        $csvData += $netRow
        
        $netRow = [PSCustomObject]@{
            "Seccion" = "Red"
            "Propiedad" = "Gateway por Defecto"
            "Valor" = $NetworkInfo.DefaultGateway
            "Timestamp" = $Timestamp
        }
        $csvData += $netRow
        
        $netRow = [PSCustomObject]@{
            "Seccion" = "Red"
            "Propiedad" = "DNS Primario"
            "Valor" = $NetworkInfo.DNSPrimary
            "Timestamp" = $Timestamp
        }
        $csvData += $netRow
        
        $netRow = [PSCustomObject]@{
            "Seccion" = "Red"
            "Propiedad" = "DNS Secundario"
            "Valor" = $NetworkInfo.DNSSecondary
            "Timestamp" = $Timestamp
        }
        $csvData += $netRow
        
        # Crear nombre de archivo y ruta
        $fileName = "${ComputerName}_${Timestamp}_system_report.csv"
        $filePath = Join-Path -Path $PhaseFolders.Fase3 -ChildPath $fileName
        
        # Exportar a CSV
        $csvData | Export-Csv -Path $filePath -Encoding UTF8 -Delimiter "," -NoTypeInformation
        
        Write-Log -Message "Archivo CSV generado: $filePath" -Level INFO
        return $filePath
        
    } catch {
        Write-Log -Message "Error en Export-ToCSV: $_" -Level ERROR
        return $null
    }
}

function Export-ToJSON {
    param(
        [hashtable]$SystemInfo,
        [array]$Disks,
        [hashtable]$NetworkInfo,
        [string]$ComputerName,
        [string]$Timestamp,
        [hashtable]$PhaseFolders
    )
    
    try {
        # Validación de datos
        if (-not $SystemInfo -or -not $Disks -or -not $NetworkInfo) {
            Write-Log -Message "Datos insuficientes para exportar a JSON" -Level ERROR
            return $null
        }
        
        # Preparar estructura de datos para JSON
        $jsonData = @{
            Timestamp = $Timestamp
            ComputerName = $ComputerName
            SystemInfo = $SystemInfo
            Disks = $Disks
            NetworkInfo = $NetworkInfo
        }
        
        # Crear nombre de archivo y ruta
        $fileName = "${ComputerName}_${Timestamp}_system_report.json"
        $filePath = Join-Path -Path $PhaseFolders.Fase3 -ChildPath $fileName
        
        # Convertir a JSON y exportar
        $jsonData | ConvertTo-Json -Depth 5 | Out-File -FilePath $filePath -Encoding UTF8
        
        Write-Log -Message "Archivo JSON generado: $filePath" -Level INFO
        return $filePath
        
    } catch {
        Write-Log -Message "Error en Export-ToJSON: $_" -Level ERROR
        return $null
    }
}

function Export-ToHTML {
    param(
        [hashtable]$SystemInfo,
        [array]$Disks,
        [hashtable]$NetworkInfo,
        [string]$ComputerName,
        [string]$Timestamp,
        [hashtable]$PhaseFolders
    )
    
    try {
        # Validación de datos
        if (-not $SystemInfo -or -not $Disks -or -not $NetworkInfo) {
            Write-Log -Message "Datos insuficientes para exportar a HTML" -Level ERROR
            return $null
        }
        
        # Crear nombre de archivo y ruta
        $fileName = "${ComputerName}_${Timestamp}_system_report.html"
        $filePath = Join-Path -Path $PhaseFolders.Fase3 -ChildPath $fileName
        
        # Generar contenido HTML
        $htmlContent = @"
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reporte del Sistema - $ComputerName</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            background-color: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            margin-top: 30px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 5px solid #3498db;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        th {
            background-color: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        tr:hover {
            background-color: #e8f4fc;
        }
        
        .disks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .disk-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .disk-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .disk-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .disk-value {
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .disk-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .timestamp {
            color: #7f8c8d;
            font-style: italic;
            text-align: right;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        
        .status-good {
            color: #27ae60;
            font-weight: bold;
        }
        
        .status-warning {
            color: #f39c12;
            font-weight: bold;
        }
        
        .status-critical {
            color: #e74c3c;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📊 Reporte del Sistema - $($SystemInfo.ComputerName)</h1>
        
        <div class="timestamp">
            Generado el: $Timestamp
        </div>
        
        <div class="section">
            <h2>🖥️ Información del Sistema</h2>
            <table>
                <tr>
                    <th>Propiedad</th>
                    <th>Valor</th>
                </tr>
                <tr>
                    <td>Nombre del Equipo</td>
                    <td>$($SystemInfo.ComputerName)</td>
                </tr>
                <tr>
                    <td>Sistema Operativo</td>
                    <td>$($SystemInfo.OSName)</td>
                </tr>
                <tr>
                    <td>Arquitectura</td>
                    <td>$($SystemInfo.OSArchitecture)</td>
                </tr>
                <tr>
                    <td>Memoria Total</td>
                    <td>$($SystemInfo.TotalMemoryGB) GB</td>
                </tr>
                <tr>
                    <td>Procesador</td>
                    <td>$($SystemInfo.Processor)</td>
                </tr>
            </table>
        </div>
        
        <div class="section">
            <h2>💾 Discos y Almacenamiento</h2>
            <div class="disks-grid">
"@

        # Agregar información de discos
        foreach ($disk in $Disks) {
            $freePercent = [double]$disk.FreeSpacePercent
            $statusClass = "status-good"
            if ($freePercent -lt 10) {
                $statusClass = "status-critical"
            } elseif ($freePercent -lt 20) {
                $statusClass = "status-warning"
            }
            
            $htmlContent += @"
                <div class="disk-card">
                    <div class="disk-title">Unidad $($disk.DriveLetter)</div>
                    <div class="disk-info">
                        <div>
                            <div class="disk-label">Tamaño Total</div>
                            <div class="disk-value">$($disk.TotalSizeGB) GB</div>
                        </div>
                        <div>
                            <div class="disk-label">Espacio Libre</div>
                            <div class="disk-value $statusClass">$($disk.FreeSpaceGB) GB</div>
                        </div>
                        <div>
                            <div class="disk-label">Espacio Usado</div>
                            <div class="disk-value">$($disk.UsedSpaceGB) GB</div>
                        </div>
                        <div>
                            <div class="disk-label">% Libre</div>
                            <div class="disk-value $statusClass">$($disk.FreeSpacePercent)%</div>
                        </div>
                    </div>
                </div>
"@
        }

        $htmlContent += @"
            </div>
        </div>
        
        <div class="section">
            <h2>🌐 Configuración de Red</h2>
            <table>
                <tr>
                    <th>Propiedad</th>
                    <th>Valor</th>
                </tr>
                <tr>
                    <td>Hostname</td>
                    <td>$($NetworkInfo.Hostname)</td>
                </tr>
                <tr>
                    <td>Dirección IP</td>
                    <td>$($NetworkInfo.IPAddress)</td>
                </tr>
                <tr>
                    <td>Máscara de Subred</td>
                    <td>$($NetworkInfo.SubnetMask)</td>
                </tr>
                <tr>
                    <td>Gateway por Defecto</td>
                    <td>$($NetworkInfo.DefaultGateway)</td>
                </tr>
                <tr>
                    <td>DNS Primario</td>
                    <td>$($NetworkInfo.DNSPrimary)</td>
                </tr>
                <tr>
                    <td>DNS Secundario</td>
                    <td>$($NetworkInfo.DNSSecondary)</td>
                </tr>
            </table>
        </div>
        
        <div class="timestamp">
            Reporte generado por SecureNAS Script v3.0 | Innova Consultoría
        </div>
    </div>
</body>
</html>
"@

        # Guardar archivo HTML
        $htmlContent | Out-File -FilePath $filePath -Encoding UTF8
        
        Write-Log -Message "Archivo HTML generado: $filePath" -Level INFO
        return $filePath
        
    } catch {
        Write-Log -Message "Error en Export-ToHTML: $_" -Level ERROR
        return $null
    }
}

function Export-ToMarkdown {
    param(
        [hashtable]$SystemInfo,
        [array]$Disks,
        [hashtable]$NetworkInfo,
        [string]$ComputerName,
        [string]$Timestamp,
        [hashtable]$PhaseFolders
    )
    
    try {
        # Validación de datos
        if (-not $SystemInfo -or -not $Disks -or -not $NetworkInfo) {
            Write-Log -Message "Datos insuficientes para exportar a Markdown" -Level ERROR
            return $null
        }
        
        # Crear nombre de archivo y ruta
        $fileName = "${ComputerName}_${Timestamp}_system_report.md"
        $filePath = Join-Path -Path $PhaseFolders.Fase3 -ChildPath $fileName
        
        # Generar contenido Markdown
        $mdContent = @"
# Reporte del Sistema - $($SystemInfo.ComputerName)

**Fecha de generación:** $Timestamp  
**Nombre del equipo:** $($SystemInfo.ComputerName)

---

## 🖥️ Información del Sistema

| Propiedad | Valor |
|-----------|-------|
| **Nombre del Equipo** | $($SystemInfo.ComputerName) |
| **Sistema Operativo** | $($SystemInfo.OSName) |
| **Arquitectura** | $($SystemInfo.OSArchitecture) |
| **Memoria Total** | $($SystemInfo.TotalMemoryGB) GB |
| **Procesador** | $($SystemInfo.Processor) |

---

## 💾 Discos y Almacenamiento

"@

        # Agregar información de discos
        foreach ($disk in $Disks) {
            $freePercent = [double]$disk.FreeSpacePercent
            $statusIcon = "✅"
            if ($freePercent -lt 10) {
                $statusIcon = "🚨"
            } elseif ($freePercent -lt 20) {
                $statusIcon = "⚠️"
            }
            
            $mdContent += @"
### $statusIcon Unidad $($disk.DriveLetter)

| Propiedad | Valor |
|-----------|-------|
| **Tamaño Total** | $($disk.TotalSizeGB) GB |
| **Espacio Libre** | $($disk.FreeSpaceGB) GB |
| **Espacio Usado** | $($disk.UsedSpaceGB) GB |
| **Porcentaje Libre** | **$($disk.FreeSpacePercent)%** |

"@
        }

        $mdContent += @"
---

## 🌐 Configuración de Red

| Propiedad | Valor |
|-----------|-------|
| **Hostname** | $($NetworkInfo.Hostname) |
| **Dirección IP** | $($NetworkInfo.IPAddress) |
| **Máscara de Subred** | $($NetworkInfo.SubnetMask) |
| **Gateway por Defecto** | $($NetworkInfo.DefaultGateway) |
| **DNS Primario** | $($NetworkInfo.DNSPrimary) |
| **DNS Secundario** | $($NetworkInfo.DNSSecondary) |

---

## 📊 Resumen de Estado

### Estado del Almacenamiento:
"@

        # Resumen de estado de discos
        foreach ($disk in $Disks) {
            $freePercent = [double]$disk.FreeSpacePercent
            $statusText = "OK"
            if ($freePercent -lt 10) {
                $statusText = "CRÍTICO - Espacio bajo"
            } elseif ($freePercent -lt 20) {
                $statusText = "ADVERTENCIA - Espacio limitado"
            }
            
            $mdContent += @"
- **Unidad $($disk.DriveLetter):** $statusText ($($disk.FreeSpacePercent)% libre)
"@
        }

        $mdContent += @"

### Recomendaciones:
"@

        # Recomendaciones basadas en el estado
        $criticalDisks = $Disks | Where-Object { [double]$_.FreeSpacePercent -lt 10 }
        $warningDisks = $Disks | Where-Object { [double]$_.FreeSpacePercent -lt 20 -and [double]$_.FreeSpacePercent -ge 10 }
        
        if ($criticalDisks) {
            $mdContent += @"
- **🚨 ACCIÓN INMEDIATA REQUERIDA:** Unidad(es) con menos del 10% de espacio libre
- Considerar limpieza de archivos temporales o expansión de almacenamiento
"@
        }
        
        if ($warningDisks) {
            $mdContent += @"
- **⚠️ MONITOREAR:** Unidad(es) con menos del 20% de espacio libre
- Planificar mantenimiento de almacenamiento
"@
        }
        
        if (-not $criticalDisks -and -not $warningDisks) {
            $mdContent += @"
- **✅ TODOS LOS SISTEMAS EN ÓRDEN:** Espacio de almacenamiento adecuado
"@
        }

        $mdContent += @"

---

*Reporte generado por SecureNAS Script v3.0*  
*Innova Consultoría - $Timestamp*
"@

        # Guardar archivo Markdown
        $mdContent | Out-File -FilePath $filePath -Encoding UTF8
        
        Write-Log -Message "Archivo Markdown generado: $filePath" -Level INFO
        return $filePath
        
    } catch {
        Write-Log -Message "Error en Export-ToMarkdown: $_" -Level ERROR
        return $null
    }
}

#endregion FUNCIONES DE FASE 3 (EXPORTACIÓN DE DATOS)

#region INICIO DEL SCRIPT PRINCIPAL
try {
    # Mostrar encabezado principal
    Write-Host "`n" + ("="*70) -ForegroundColor Green
    Write-Host "AUDITORÍA FINAL MAESTRA - INTEGRACIÓN COMPLETA" -ForegroundColor Green
    Write-Host "Versión: 3.0 (CON EXPORTACIÓN MULTIFORMATO) | Equipo: $ComputerName" -ForegroundColor Green  # ← Cambia versión
    Write-Host "Exportar HTML: $ExportHTML" -ForegroundColor Cyan  # ← NUEVA LÍNEA
    Write-Host "="*70 -ForegroundColor Green
    Write-Host "Auditoría completa diseñada por victor 3,1416" -ForegroundColor DarkGray
    Write-Host "Fecha: $(Get-Date -Format 'dd/MM/yyyy') | Hora: $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor DarkGray
    Write-Host "="*70 -ForegroundColor Green
    Write-Host ""
    
    # ✅ AÑADE: Definir variables para pasar datos entre fases
    $fase1Result = $null
    $fase2Result = $null
    $fase3Result = $null
    
    # ✅ CORRECCIÓN: Actualizar fases con manejo de parámetros
    $phases = @(
        @{
            Name = "Fase 1"
            Function = { 
                $global:CurrentPhase = 1
                if (Invoke-Fase1) {
                    # Capturar datos de Fase 1 para pasar a Fase 2
                    $script:fase1Result = @{
                        SystemInfo = $global:AuditData.SystemInfo
                        Disks = $global:AuditData.Disks
                        NetworkInfo = $global:AuditData.NetworkInfo
                        ComputerName = $ComputerName
                        Timestamp = $Timestamp
                        PhaseFolders = @{
                            Fase1 = Join-Path $OutputPath "Fase1_Recoleccion"
                            Fase2 = Join-Path $OutputPath "Fase2_Analisis"
                            Fase3 = Join-Path $OutputPath "Fase3_Exportacion"  # ← NUEVO
                        }
                    }
                    Get-SystemAuditBasic
                } else {
                    $false
                }
            }
        }
        @{
            Name = "Fase 2"
            Function = { 
                $global:CurrentPhase = 2
                # Verificar que la función existe
                if (Get-Command Invoke-Fase2 -ErrorAction SilentlyContinue) {
                    # Pasar datos de Fase 1 a Fase 2
                    if ($script:fase1Result) {
                        $result = Invoke-Fase2 @script:fase1Result
                        # Capturar resultado para pasar a Fase 3
                        $script:fase2Result = $result
                        $result
                    } else {
                        Write-Log "⚠ No hay datos de Fase 1 para procesar en Fase 2" -Level "WARNING"
                        $false
                    }
                } else {
                    Write-Log "⚠ Fase 2 no disponible (función no definida)" -Level "WARNING"
                    $true  # Continuar con las demás fases
                }
            }
        }
        @{
            Name = "Fase 3"
            Function = { 
                $global:CurrentPhase = 3
                if (Get-Command Invoke-Fase3 -ErrorAction SilentlyContinue) {
                    # Pasar datos de Fase 2 a Fase 3
                    if ($script:fase2Result) {
                        $result = Invoke-Fase3 @script:fase2Result -ExportHTML:$ExportHTML
                        # Capturar resultado para mostrar después
                        $script:fase3Result = $result
                        $result
                    } else {
                        Write-Log "⚠ No hay datos de Fase 2 para procesar en Fase 3" -Level "WARNING"
                        $false
                    }
                } else {
                    Write-Log "⚠ Fase 3 no disponible (función no definida)" -Level "WARNING"
                    $true
                }
            }
        }
        @{
            Name = "Fase 4"
            Function = { 
                $global:CurrentPhase = 4
                if (Get-Command Invoke-Fase4 -ErrorAction SilentlyContinue) {
                    Invoke-Fase4
                } else {
                    Write-Log "⚠ Fase 4 no disponible (función no definida)" -Level "WARNING"
                    $true
                }
            }
        }
        @{
            Name = "Fase 5"
            Function = { 
                $global:CurrentPhase = 5
                if (Get-Command Invoke-Fase5 -ErrorAction SilentlyContinue) {
                    Invoke-Fase5
                } else {
                    Write-Log "⚠ Fase 5 no disponible (función no definida)" -Level "WARNING"
                    $true
                }
            }
        }
    )
    
    # ✅ AÑADE: Crear carpeta para Fase 3
    $fase3Folder = Join-Path $OutputPath "Fase3_Exportacion"
    if (-not (Test-Path $fase3Folder)) {
        New-Item -ItemType Directory -Path $fase3Folder -Force | Out-Null
        Write-Log "Carpeta Fase 3 creada: $fase3Folder" -Level "INFO"
    }
    
    $phaseResults = @{}
    $phaseNumber = 1
    
    foreach ($phase in $phases) {
        Write-Host "`n" + ("="*60) -ForegroundColor Cyan
        Write-Host "INICIANDO $($phase.Name.ToUpper())" -ForegroundColor Cyan
        Write-Host "="*60 -ForegroundColor Cyan
        
        try {
            # Ejecutar la fase
            $result = & $phase.Function
            $phaseResults[$phase.Name] = $result
            
            if ($result) {
                Write-Host "`n✅ $($phase.Name) COMPLETADA EXITOSAMENTE" -ForegroundColor Green
                
                # ✅ AÑADE: Mostrar detalles específicos de Fase 3
                if ($phase.Name -eq "Fase 3" -and $script:fase3Result -and $script:fase3Result.Results) {
                    Write-Host "   Formatos exportados:" -ForegroundColor Cyan
                    $exported = @()
                    if ($script:fase3Result.Results.CSV) { $exported += "CSV" }
                    if ($script:fase3Result.Results.JSON) { $exported += "JSON" }
                    if ($script:fase3Result.Results.HTML -and $ExportHTML) { $exported += "HTML" }
                    if ($script:fase3Result.Results.Markdown) { $exported += "Markdown" }
                    Write-Host "   • " + ($exported -join ", ") -ForegroundColor White
                }
            } else {
                Write-Host "`n⚠️  $($phase.Name) COMPLETADA CON ADVERTENCIAS" -ForegroundColor Yellow
            }
        }
        catch {
            Write-Log "Error en $($phase.Name): $_" -Level "ERROR"
            Write-Host "`n❌ $($phase.Name) FALLÓ: $_" -ForegroundColor Red
            
            # Preguntar si continuar (solo si no es la última fase)
            if ($phaseNumber -lt $phases.Count) {
                Write-Host "`n¿Desea continuar con la siguiente fase? (S/N): " -ForegroundColor Yellow -NoNewline
                $response = Read-Host
                if ($response -notmatch '^[Ss]$') {
                    Write-Host "Auditoría interrumpida por el usuario." -ForegroundColor Red
                    break
                }
            }
        }
        
        $phaseNumber++
    }
    
    # Resumen final
    Write-Host "`n" + ("="*70) -ForegroundColor Green
    Write-Host "AUDITORÍA COMPLETADA" -ForegroundColor Green
    Write-Host "="*70 -ForegroundColor Green
    Write-Host ""
    
    # Mostrar estadísticas finales
    $successfulPhases = ($phaseResults.Values | Where-Object { $_ -eq $true }).Count
    $failedPhases = ($phaseResults.Values | Where-Object { $_ -eq $false }).Count
    
    Write-Host "📊 RESULTADOS FINALES:" -ForegroundColor Cyan
    Write-Host "   * Fases completadas exitosamente: $successfulPhases/$($phases.Count)" -ForegroundColor White
    Write-Host "   * Fases con advertencias/errores: $failedPhases/$($phases.Count)" -ForegroundColor White
    
    $totalDuration = [math]::Round(((Get-Date) - $scriptStartTime).TotalSeconds, 2)
    Write-Host "   * Duración total: $totalDuration segundos" -ForegroundColor White
    Write-Host ""
    
    Write-Host "📁 RESULTADOS GUARDADOS EN:" -ForegroundColor Cyan
    Write-Host "   * Carpeta principal: $OutputPath" -ForegroundColor White
    Write-Host "   * Archivo de log: $LogFile" -ForegroundColor White
    
    # ✅ MODIFICA: Mostrar archivos generados (añade Fase 3)
    Write-Host "`n📂 CARPETAS DE RESULTADOS:" -ForegroundColor Magenta
    if (Test-Path (Join-Path $OutputPath "Fase1_Recoleccion")) {
        Write-Host "   • Fase 1 (Recolección): $(Join-Path $OutputPath "Fase1_Recoleccion")" -ForegroundColor Gray
    }
    if (Test-Path (Join-Path $OutputPath "Fase2_Analisis")) {
        Write-Host "   • Fase 2 (Análisis): $(Join-Path $OutputPath "Fase2_Analisis")" -ForegroundColor Gray
    }
    if (Test-Path $fase3Folder) {
        Write-Host "   • Fase 3 (Exportación): $fase3Folder" -ForegroundColor Gray  # ← NUEVO
        
        # Mostrar archivos específicos de Fase 3
        if ($script:fase3Result -and $script:fase3Result.Files) {
            Write-Host "`n   Archivos de exportación generados:" -ForegroundColor Cyan
            foreach ($format in @('CSV', 'JSON', 'HTML', 'Markdown')) {
                if ($script:fase3Result.Files[$format]) {
                    $fileName = Split-Path $script:fase3Result.Files[$format] -Leaf
                    Write-Host "     • $format : $fileName" -ForegroundColor White
                }
            }
        }
    }
    
    # ✅ MODIFICA: Añade los archivos de Fase 3 al resumen
    if (Test-Path $UnifiedJSON) {
        Write-Host "   * Reporte JSON: $UnifiedJSON" -ForegroundColor White
    }
    if (Test-Path $UnifiedCSV) {
        Write-Host "   * Reporte CSV: $UnifiedCSV" -ForegroundColor White
    }
    
    # ✅ AÑADE: Mostrar archivos de Fase 3 si existen
    if ($script:fase3Result -and $script:fase3Result.Files) {
        foreach ($format in @('CSV', 'JSON', 'HTML', 'Markdown')) {
            if ($script:fase3Result.Files[$format] -and (Test-Path $script:fase3Result.Files[$format])) {
                Write-Host "   * Reporte $format : $($script:fase3Result.Files[$format])" -ForegroundColor White
            }
        }
    }
    
    Write-Host "`n" + ("="*70) -ForegroundColor Green
    Write-Host "✅ AUDITORÍA FINALIZADA" -ForegroundColor Green
    Write-Host "="*70 -ForegroundColor Green
    
    Write-Log "=== FIN DE AUDITORÍA COMPLETA ===" -Level "SUCCESS"
    Write-Log "Duración total: $totalDuration segundos" -Level "INFO"
    Write-Log "Exportación HTML habilitada: $ExportHTML" -Level "INFO"  # ← NUEVO
    
    # ✅ AÑADE: Log de resultados de Fase 3
    if ($script:fase3Result -and $script:fase3Result.Results) {
        Write-Log "Resultados Fase 3:" -Level "INFO"
        foreach ($format in @('CSV', 'JSON', 'HTML', 'Markdown')) {
            if ($script:fase3Result.Results[$format]) {
                $file = Split-Path $script:fase3Result.Files[$format] -Leaf
                Write-Log "  • $format exportado: $file" -Level "SUCCESS"
            }
        }
    }
    
    # Pausar antes de finalizar para que el usuario pueda ver los resultados
    Write-Host "`nLa auditoría ha finalizado. El script se cerrará en 5 segundos..." -ForegroundColor Green
    Start-Sleep -Seconds 5
    
    exit 0
}
catch {
    Write-Log "Error crítico en el script principal: $_" -Level "ERROR"
    Write-Host "`n❌ ERROR CRÍTICO: $_" -ForegroundColor Red
    Write-Host "`n📄 Revisa el archivo de log para más detalles: $LogFile" -ForegroundColor Yellow
    
    Write-Host "`nLa auditoría ha finalizado. El script se cerrará en 5 segundos..." -ForegroundColor Green
    Start-Sleep -Seconds 5
    
    exit 1
}
finally {
    # Asegurar que el log se cierre correctamente
    if ($LogFile -and (Test-Path $LogFile)) {
        "=== Script finalizado a las $(Get-Date -Format 'HH:mm:ss') ===" | Out-File -FilePath $LogFile -Append -Encoding UTF8
    }
}
#endregion

# ============================================
# FIN DEL SCRIPT
# ============================================
